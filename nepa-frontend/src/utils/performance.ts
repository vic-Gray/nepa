import { useCallback, useEffect, useRef, useState } from 'react';\n\n// Performance monitoring utilities\nexport interface PerformanceMetrics {\n  fcp: number; // First Contentful Paint\n  lcp: number; // Largest Contentful Paint\n  cls: number; // Cumulative Layout Shift\n  tti: number; // Time to Interactive\n  bundleSize: number;\n  memoryUsage: number;\n}\n\nexport interface PerformanceEntry {\n  name: string;\n  value: number;\n  timestamp: number;\n}\n\n// Performance monitoring class\nexport class PerformanceMonitor {\n  private metrics: PerformanceEntry[] = [];\n  private observers: PerformanceObserver[] = [];\n\n  constructor() {\n    this.initializeObservers();\n  }\n\n  private initializeObservers() {\n    // Observe Core Web Vitals\n    if ('PerformanceObserver' in window) {\n      // First Contentful Paint\n      const fcpObserver = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          if (entry.name === 'first-contentful-paint') {\n            this.recordMetric('FCP', entry.startTime);\n          }\n        }\n      });\n      fcpObserver.observe({ entryTypes: ['paint'] });\n      this.observers.push(fcpObserver);\n\n      // Largest Contentful Paint\n      const lcpObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        const lastEntry = entries[entries.length - 1];\n        if (lastEntry) {\n          this.recordMetric('LCP', lastEntry.startTime);\n        }\n      });\n      lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });\n      this.observers.push(lcpObserver);\n\n      // Cumulative Layout Shift\n      const clsObserver = new PerformanceObserver((list) => {\n        let clsValue = 0;\n        for (const entry of list.getEntries()) {\n          if (!(entry as any).hadRecentInput) {\n            clsValue += (entry as any).value;\n          }\n        }\n        this.recordMetric('CLS', clsValue);\n      });\n      clsObserver.observe({ entryTypes: ['layout-shift'] });\n      this.observers.push(clsObserver);\n\n      // Time to Interactive (approximation)\n      const ttiObserver = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          if (entry.entryType === 'longtask') {\n            this.recordMetric('TTI', entry.startTime + entry.duration);\n          }\n        }\n      });\n      ttiObserver.observe({ entryTypes: ['longtask'] });\n      this.observers.push(ttiObserver);\n    }\n  }\n\n  private recordMetric(name: string, value: number) {\n    this.metrics.push({\n      name,\n      value,\n      timestamp: Date.now(),\n    });\n\n    // Store in localStorage for persistence\n    try {\n      const existing = JSON.parse(localStorage.getItem('performance-metrics') || '[]');\n      existing.push({ name, value, timestamp: Date.now() });\n      localStorage.setItem('performance-metrics', JSON.stringify(existing));\n    } catch (error) {\n      console.warn('Failed to store performance metrics:', error);\n    }\n  }\n\n  getMetrics(): PerformanceMetrics {\n    const latest = this.metrics.reduce((acc, metric) => {\n      acc[metric.name.toLowerCase() as keyof PerformanceMetrics] = metric.value;\n      return acc;\n    }, {} as PerformanceMetrics);\n\n    return {\n      fcp: latest.fcp || 0,\n      lcp: latest.lcp || 0,\n      cls: latest.cls || 0,\n      tti: latest.tti || 0,\n      bundleSize: this.getBundleSize(),\n      memoryUsage: this.getMemoryUsage(),\n    };\n  }\n\n  private getBundleSize(): number {\n    // Approximate bundle size based on loaded resources\n    const resources = performance.getEntriesByType('resource');\n    return resources.reduce((size, resource) => size + (resource.transferSize || 0), 0);\n  }\n\n  private getMemoryUsage(): number {\n    if ('memory' in performance) {\n      return (performance as any).memory.usedJSHeapSize;\n    }\n    return 0;\n  }\n\n  cleanup() {\n    this.observers.forEach(observer => observer.disconnect());\n    this.observers = [];\n  }\n}\n\n// Debounce utility for performance optimization\nexport function useDebounce<T extends (...args: any[]) => any>(\n  callback: T,\n  delay: number\n): T {\n  const timeoutRef = useRef<NodeJS.Timeout>();\n\n  return useCallback((...args: Parameters<T>) => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    timeoutRef.current = setTimeout(() => callback(...args), delay);\n  }, [callback, delay]);\n}\n\n// Throttle utility for performance optimization\nexport function useThrottle<T extends (...args: any[]) => any>(\n  callback: T,\n  delay: number\n): T {\n  const lastCall = useRef<number>(0);\n\n  return useCallback((...args: Parameters<T>) => {\n    const now = Date.now();\n    if (now - lastCall.current >= delay) {\n      lastCall.current = now;\n      callback(...args);\n    }\n  }, [callback, delay]);\n}\n\n// Lazy loading utility\nexport function useLazyLoad<T>(\n  loader: () => Promise<T>,\n  dependencies: any[] = []\n) {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    let cancelled = false;\n\n    const loadData = async () => {\n      setLoading(true);\n      setError(null);\n      try {\n        const result = await loader();\n        if (!cancelled) {\n          setData(result);\n        }\n      } catch (err) {\n        if (!cancelled) {\n          setError(err as Error);\n        }\n      } finally {\n        if (!cancelled) {\n          setLoading(false);\n        }\n      }\n    };\n\n    loadData();\n\n    return () => {\n      cancelled = true;\n    };\n  }, dependencies);\n\n  return { data, loading, error };\n}\n\n// Virtual scrolling utility for large lists\nexport function useVirtualScroll(\n  items: any[],\n  itemHeight: number,\n  containerHeight: number\n) {\n  const [scrollTop, setScrollTop] = useState(0);\n\n  const visibleItems = useMemo(() => {\n    const startIndex = Math.floor(scrollTop / itemHeight);\n    const endIndex = Math.min(\n      startIndex + Math.ceil(containerHeight / itemHeight) + 1,\n      items.length\n    );\n    \n    return items.slice(startIndex, endIndex).map((item, index) => ({\n      item,\n      index: startIndex + index,\n    }));\n  }, [items, scrollTop, itemHeight, containerHeight]);\n\n  const totalHeight = items.length * itemHeight;\n\n  return {\n    visibleItems,\n    totalHeight,\n    onScroll: useCallback((e: React.UIEvent<HTMLDivElement>) => {\n      setScrollTop(e.currentTarget.scrollTop);\n    }, []),\n  };\n}\n\n// Image optimization utility\nexport function optimizeImage(src: string, options: {\n  width?: number;\n  height?: number;\n  quality?: number;\n  format?: 'webp' | 'avif' | 'jpeg' | 'png';\n} = {}): string {\n  const { width, height, quality = 80, format = 'webp' } = options;\n  \n  // This is a simplified version - in production, you'd use an image CDN\n  const params = new URLSearchParams();\n  if (width) params.append('w', width.toString());\n  if (height) params.append('h', height.toString());\n  params.append('q', quality.toString());\n  params.append('f', format);\n  \n  const separator = src.includes('?') ? '&' : '?';\n  return `${src}${separator}${params.toString()}`;\n}\n\n// Bundle analysis utility\nexport function analyzeBundle() {\n  if ('performance' in window && 'memory' in performance) {\n    const memory = (performance as any).memory;\n    return {\n      usedJSHeapSize: memory.usedJSHeapSize,\n      totalJSHeapSize: memory.totalJSHeapSize,\n      jsHeapSizeLimit: memory.jsHeapSizeLimit,\n    };\n  }\n  return null;\n}\n\n// Cache utilities\nexport class CacheManager {\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n\n  set(key: string, data: any, ttl: number = 300000) { // 5 minutes default TTL\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl,\n    });\n  }\n\n  get(key: string): any | null {\n    const item = this.cache.get(key);\n    if (!item) return null;\n\n    if (Date.now() - item.timestamp > item.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return item.data;\n  }\n\n  clear() {\n    this.cache.clear();\n  }\n\n  // Cleanup expired entries\n  cleanup() {\n    const now = Date.now();\n    for (const [key, item] of this.cache.entries()) {\n      if (now - item.timestamp > item.ttl) {\n        this.cache.delete(key);\n      }\n    }\n  }\n}\n\n// Service Worker registration\nexport function registerServiceWorker() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.register('/sw.js')\n      .then((registration) => {\n        console.log('SW registered:', registration);\n      })\n      .catch((error) => {\n        console.log('SW registration failed:', error);\n      });\n  }\n}\n\n// Preload critical resources\nexport function preloadResources(resources: string[]) {\n  resources.forEach(resource => {\n    const link = document.createElement('link');\n    link.rel = 'preload';\n    link.href = resource;\n    \n    // Determine type based on extension\n    if (resource.endsWith('.css')) {\n      link.as = 'style';\n    } else if (resource.endsWith('.js')) {\n      link.as = 'script';\n    } else if (resource.match(/\\.(jpg|jpeg|png|webp|avif)$/)) {\n      link.as = 'image';\n    }\n    \n    document.head.appendChild(link);\n  });\n}\n\n// Critical CSS inlining\nexport function inlineCriticalCSS(css: string) {\n  const style = document.createElement('style');\n  style.textContent = css;\n  document.head.appendChild(style);\n}\n\n// Resource hints\nexport function addResourceHints() {\n  // DNS prefetch\n  const dnsPrefetch = [\n    '//fonts.googleapis.com',\n    '//api.github.com',\n    '//cdn.jsdelivr.net',\n  ];\n\n  dnsPrefetch.forEach(domain => {\n    const link = document.createElement('link');\n    link.rel = 'dns-prefetch';\n    link.href = `https:${domain}`;\n    document.head.appendChild(link);\n  });\n\n  // Preconnect to critical domains\n  const preconnect = [\n    'https://fonts.googleapis.com',\n    'https://fonts.gstatic.com',\n  ];\n\n  preconnect.forEach(url => {\n    const link = document.createElement('link');\n    link.rel = 'preconnect';\n    link.href = url;\n    document.head.appendChild(link);\n  });\n}
