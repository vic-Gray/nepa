import React, { useState, useEffect, useCallback, useRef } from 'react';\nimport { AlertCircle, Check, Eye, EyeOff, Loader2 } from 'lucide-react';\n\ninterface ValidationRule {\n  required?: boolean;\n  minLength?: number;\n  maxLength?: number;\n  min?: number;\n  max?: number;\n  pattern?: RegExp;\n  customValidator?: (value: any) => string | null;\n  message?: string;\n}\n\ninterface FormField {\n  name: string;\n  label: string;\n  type: 'text' | 'email' | 'password' | 'number' | 'tel' | 'url' | 'date' | 'select' | 'textarea' | 'checkbox' | 'radio';\n  placeholder?: string;\n  options?: { value: string; label: string }[];\n  validation?: ValidationRule;\n  disabled?: boolean;\n  className?: string;\n  showPasswordToggle?: boolean;\n  autoComplete?: string;\n  ariaLabel?: string;\n  ariaDescribedBy?: string;\n}\n\ninterface FormConfig {\n  fields: FormField[];\n  onSubmit: (data: any) => Promise<void>;\n  initialValues?: { [key: string]: any };\n  submitButtonText?: string;\n  submitButtonClassName?: string;\n  className?: string;\n  realTimeValidation?: boolean;\n  showValidationSummary?: boolean;\n  accessibilityMode?: boolean;\n}\n\ninterface ValidationError {\n  field: string;\n  message: string;\n  type: 'error' | 'warning' | 'info';\n}\n\ninterface FormState {\n  values: { [key: string]: any };\n  errors: { [key: string]: string[] };\n  touched: { [key: string]: boolean };\n  isValid: boolean;\n  isSubmitting: boolean;\n  isDirty: boolean;\n}\n\nexport const AdvancedForm: React.FC<FormConfig> = ({\n  fields,\n  onSubmit,\n  initialValues = {},\n  submitButtonText = 'Submit',\n  submitButtonClassName = '',\n  className = '',\n  realTimeValidation = true,\n  showValidationSummary = true,\n  accessibilityMode = false\n}) => {\n  const [formState, setFormState] = useState<FormState>({\n    values: { ...initialValues },\n    errors: {},\n    touched: {},\n    isValid: false,\n    isSubmitting: false,\n    isDirty: false\n  });\n\n  const [showPasswords, setShowPasswords] = useState<{ [key: string]: boolean }>({});\n  const [focusedField, setFocusedField] = useState<string | null>(null);\n  const [validationSummary, setValidationSummary] = useState<ValidationError[]>([]);\n  const formRef = useRef<HTMLFormElement>(null);\n  const fieldRefs = useRef<{ [key: string]: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement }>({});\n\n  // Validate a single field\n  const validateField = useCallback((fieldName: string, value: any, allValues: any): string[] => {\n    const field = fields.find(f => f.name === fieldName);\n    if (!field?.validation) return [];\n\n    const errors: string[] = [];\n    const validation = field.validation;\n\n    // Required validation\n    if (validation.required && (!value || value.toString().trim() === '')) {\n      errors.push(validation.message || `${field.label} is required`);\n    }\n\n    // Skip other validations if field is empty and not required\n    if (!value || value.toString().trim() === '') return errors;\n\n    // Length validations\n    if (validation.minLength && value.toString().length < validation.minLength) {\n      errors.push(validation.message || `${field.label} must be at least ${validation.minLength} characters`);\n    }\n\n    if (validation.maxLength && value.toString().length > validation.maxLength) {\n      errors.push(validation.message || `${field.label} must not exceed ${validation.maxLength} characters`);\n    }\n\n    // Number validations\n    if (field.type === 'number') {\n      const numValue = parseFloat(value);\n      if (validation.min !== undefined && numValue < validation.min) {\n        errors.push(validation.message || `${field.label} must be at least ${validation.min}`);\n      }\n      if (validation.max !== undefined && numValue > validation.max) {\n        errors.push(validation.message || `${field.label} must not exceed ${validation.max}`);\n      }\n    }\n\n    // Pattern validation\n    if (validation.pattern && !validation.pattern.test(value.toString())) {\n      errors.push(validation.message || `${field.label} format is invalid`);\n    }\n\n    // Email validation\n    if (field.type === 'email') {\n      const emailPattern = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n      if (!emailPattern.test(value.toString())) {\n        errors.push(validation.message || `${field.label} must be a valid email address`);\n      }\n    }\n\n    // Password validation\n    if (field.type === 'password') {\n      const password = value.toString();\n      if (password.length < 8) {\n        errors.push('Password must be at least 8 characters');\n      }\n      if (!/(?=.*[a-z])/.test(password)) {\n        errors.push('Password must contain at least one lowercase letter');\n      }\n      if (!/(?=.*[A-Z])/.test(password)) {\n        errors.push('Password must contain at least one uppercase letter');\n      }\n      if (!/(?=.*\\d)/.test(password)) {\n        errors.push('Password must contain at least one number');\n      }\n      if (!/(?=.*[@$!%*?&])/.test(password)) {\n        errors.push('Password must contain at least one special character');\n      }\n    }\n\n    // Phone validation\n    if (field.type === 'tel') {\n      const phonePattern = /^[+]?[\\d\\s\\-()]+$/;\n      if (!phonePattern.test(value.toString())) {\n        errors.push(validation.message || `${field.label} must be a valid phone number`);\n      }\n    }\n\n    // URL validation\n    if (field.type === 'url') {\n      try {\n        new URL(value.toString());\n      } catch {\n        errors.push(validation.message || `${field.label} must be a valid URL`);\n      }\n    }\n\n    // Custom validator\n    if (validation.customValidator) {\n      const customError = validation.customValidator(value);\n      if (customError) {\n        errors.push(customError);\n      }\n    }\n\n    return errors;\n  }, [fields]);\n\n  // Validate entire form\n  const validateForm = useCallback((values: any): { [key: string]: string[] } => {\n    const errors: { [key: string]: string[] } = {};\n    \n    fields.forEach(field => {\n      const fieldErrors = validateField(field.name, values[field.name], values);\n      if (fieldErrors.length > 0) {\n        errors[field.name] = fieldErrors;\n      }\n    });\n\n    return errors;\n  }, [fields, validateField]);\n\n  // Update validation summary\n  useEffect(() => {\n    const summary: ValidationError[] = [];\n    Object.entries(formState.errors).forEach(([field, errors]) => {\n      errors.forEach(error => {\n        summary.push({ field, message: error, type: 'error' });\n      });\n    });\n    setValidationSummary(summary);\n  }, [formState.errors]);\n\n  // Handle field value change\n  const handleFieldChange = useCallback((fieldName: string, value: any) => {\n    setFormState(prev => {\n      const newValues = { ...prev.values, [fieldName]: value };\n      const newTouched = { ...prev.touched, [fieldName]: true };\n      \n      let newErrors = { ...prev.errors };\n      \n      if (realTimeValidation && newTouched[fieldName]) {\n        const fieldErrors = validateField(fieldName, value, newValues);\n        if (fieldErrors.length > 0) {\n          newErrors[fieldName] = fieldErrors;\n        } else {\n          delete newErrors[fieldName];\n        }\n      }\n\n      const isValid = Object.keys(newErrors).length === 0;\n      const isDirty = JSON.stringify(newValues) !== JSON.stringify(initialValues);\n\n      return {\n        ...prev,\n        values: newValues,\n        errors: newErrors,\n        touched: newTouched,\n        isValid,\n        isDirty\n      };\n    });\n  }, [realTimeValidation, validateField, initialValues]);\n\n  // Handle field blur\n  const handleFieldBlur = useCallback((fieldName: string) => {\n    setFormState(prev => {\n      const newTouched = { ...prev.touched, [fieldName]: true };\n      const fieldErrors = validateField(fieldName, prev.values[fieldName], prev.values);\n      const newErrors = { ...prev.errors };\n      \n      if (fieldErrors.length > 0) {\n        newErrors[fieldName] = fieldErrors;\n      } else {\n        delete newErrors[fieldName];\n      }\n\n      const isValid = Object.keys(newErrors).length === 0;\n\n      return {\n        ...prev,\n        errors: newErrors,\n        touched: newTouched,\n        isValid\n      };\n    });\n    setFocusedField(null);\n  }, [validateField]);\n\n  // Handle form submission\n  const handleSubmit = useCallback(async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    // Validate all fields\n    const errors = validateForm(formState.values);\n    \n    if (Object.keys(errors).length > 0) {\n      setFormState(prev => ({\n        ...prev,\n        errors,\n        touched: fields.reduce((acc, field) => ({ ...acc, [field.name]: true }), {})\n      }));\n      \n      // Focus first error field\n      const firstErrorField = Object.keys(errors)[0];\n      if (firstErrorField && fieldRefs.current[firstErrorField]) {\n        fieldRefs.current[firstErrorField].focus();\n      }\n      \n      return;\n    }\n\n    setFormState(prev => ({ ...prev, isSubmitting: true }));\n\n    try {\n      await onSubmit(formState.values);\n      // Reset form on successful submission\n      setFormState({\n        values: { ...initialValues },\n        errors: {},\n        touched: {},\n        isValid: false,\n        isSubmitting: false,\n        isDirty: false\n      });\n    } catch (error) {\n      setFormState(prev => ({ ...prev, isSubmitting: false }));\n    }\n  }, [formState.values, validateForm, fields, onSubmit, initialValues]);\n\n  // Toggle password visibility\n  const togglePasswordVisibility = useCallback((fieldName: string) => {\n    setShowPasswords(prev => ({ ...prev, [fieldName]: !prev[fieldName] }));\n  }, []);\n\n  // Render form field\n  const renderField = useCallback((field: FormField) => {\n    const value = formState.values[field.name] || '';\n    const errors = formState.errors[field.name] || [];\n    const isTouched = formState.touched[field.name];\n    const hasError = isTouched && errors.length > 0;\n    const isFocused = focusedField === field.name;\n    const showPassword = showPasswords[field.name];\n\n    const baseInputClasses = `\n      w-full px-3 py-2 border rounded-md transition-colors\n      ${hasError ? 'border-red-500 focus:border-red-500' : 'border-gray-300 focus:border-blue-500'}\n      ${field.disabled ? 'bg-gray-100 cursor-not-allowed' : 'bg-white'}\n      ${accessibilityMode ? 'text-lg' : ''}\n      ${field.className || ''}\n    `;\n\n    const fieldId = `field-${field.name}`;\n    const errorId = `error-${field.name}`;\n\n    return (\n      <div key={field.name} className=\"mb-4\">\n        <label \n          htmlFor={fieldId}\n          className={`block text-sm font-medium mb-1 ${\n            hasError ? 'text-red-700' : 'text-gray-700'\n          } ${accessibilityMode ? 'text-base' : ''}`}\n        >\n          {field.label}\n          {field.validation?.required && (\n            <span className=\"text-red-500 ml-1\" aria-label=\"required\">*</span>\n          )}\n        </label>\n\n        <div className=\"relative\">\n          {field.type === 'textarea' ? (\n            <textarea\n              id={fieldId}\n              ref={el => fieldRefs.current[field.name] = el as HTMLTextAreaElement}\n              value={value}\n              onChange={(e) => handleFieldChange(field.name, e.target.value)}\n              onBlur={() => handleFieldBlur(field.name)}\n              onFocus={() => setFocusedField(field.name)}\n              disabled={field.disabled}\n              placeholder={field.placeholder}\n              className={baseInputClasses}\n              aria-invalid={hasError}\n              aria-describedby={hasError ? errorId : field.ariaDescribedBy}\n              rows={4}\n            />\n          ) : field.type === 'select' ? (\n            <select\n              id={fieldId}\n              ref={el => fieldRefs.current[field.name] = el as HTMLSelectElement}\n              value={value}\n              onChange={(e) => handleFieldChange(field.name, e.target.value)}\n              onBlur={() => handleFieldBlur(field.name)}\n              onFocus={() => setFocusedField(field.name)}\n              disabled={field.disabled}\n              className={baseInputClasses}\n              aria-invalid={hasError}\n              aria-describedby={hasError ? errorId : field.ariaDescribedBy}\n            >\n              <option value=\"\">Select an option</option>\n              {field.options?.map(option => (\n                <option key={option.value} value={option.value}>\n                  {option.label}\n                </option>\n              ))}\n            </select>\n          ) : field.type === 'checkbox' ? (\n            <div className=\"flex items-center\">\n              <input\n                id={fieldId}\n                ref={el => fieldRefs.current[field.name] = el as HTMLInputElement}\n                type=\"checkbox\"\n                checked={value}\n                onChange={(e) => handleFieldChange(field.name, e.target.checked)}\n                onBlur={() => handleFieldBlur(field.name)}\n                onFocus={() => setFocusedField(field.name)}\n                disabled={field.disabled}\n                className=\"w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500\"\n                aria-invalid={hasError}\n                aria-describedby={hasError ? errorId : field.ariaDescribedBy}\n              />\n              <label htmlFor={fieldId} className=\"ml-2 text-sm text-gray-700\">\n                {field.placeholder}\n              </label>\n            </div>\n          ) : (\n            <input\n              id={fieldId}\n              ref={el => fieldRefs.current[field.name] = el as HTMLInputElement}\n              type={showPassword ? 'text' : field.type}\n              value={value}\n              onChange={(e) => handleFieldChange(field.name, e.target.value)}\n              onBlur={() => handleFieldBlur(field.name)}\n              onFocus={() => setFocusedField(field.name)}\n              disabled={field.disabled}\n              placeholder={field.placeholder}\n              autoComplete={field.autoComplete}\n              className={baseInputClasses}\n              aria-invalid={hasError}\n              aria-describedby={hasError ? errorId : field.ariaDescribedBy}\n              aria-label={field.ariaLabel}\n            />\n          )}\n\n          {field.type === 'password' && field.showPasswordToggle && (\n            <button\n              type=\"button\"\n              onClick={() => togglePasswordVisibility(field.name)}\n              className=\"absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700\"\n              aria-label={showPassword ? 'Hide password' : 'Show password'}\n            >\n              {showPassword ? <EyeOff className=\"w-4 h-4\" /> : <Eye className=\"w-4 h-4\" />}\n            </button>\n          )}\n        </div>\n\n        {/* Field errors */}\n        {hasError && (\n          <div id={errorId} className=\"mt-1\" role=\"alert\" aria-live=\"polite\">\n            {errors.map((error, index) => (\n              <div key={index} className=\"flex items-center text-sm text-red-600\">\n                <AlertCircle className=\"w-4 h-4 mr-1 flex-shrink-0\" />\n                <span>{error}</span>\n              </div>\n            ))}\n          </div>\n        )}\n\n        {/* Field hint for accessibility */}\n        {accessibilityMode && !hasError && isFocused && (\n          <div className=\"mt-1 text-sm text-gray-500\">\n            {field.type === 'email' && 'Enter a valid email address'}\n            {field.type === 'password' && 'Password must be at least 8 characters with uppercase, lowercase, number, and special character'}\n            {field.type === 'tel' && 'Enter your phone number with country code'}\n            {field.type === 'url' && 'Enter a complete URL including http:// or https://'}\n          </div>\n        )}\n      </div>\n    );\n  }, [formState, focusedField, showPasswords, accessibilityMode, handleFieldChange, handleFieldBlur, togglePasswordVisibility]);\n\n  return (\n    <form \n      ref={formRef}\n      onSubmit={handleSubmit} \n      className={`space-y-4 ${className}`}\n      noValidate\n    >\n      {/* Validation Summary */}\n      {showValidationSummary && validationSummary.length > 0 && (\n        <div \n          className=\"bg-red-50 border border-red-200 rounded-md p-4\" \n          role=\"alert\" \n          aria-live=\"assertive\"\n        >\n          <h3 className=\"text-sm font-medium text-red-800 mb-2\">\n            Please fix the following errors:\n          </h3>\n          <ul className=\"list-disc list-inside space-y-1\">\n            {validationSummary.map((error, index) => (\n              <li key={index} className=\"text-sm text-red-700\">\n                <strong>{error.field}:</strong> {error.message}\n              </li>\n            ))}\n          </ul>\n        </div>\n      )}\n\n      {/* Form Fields */}\n      {fields.map(renderField)}\n\n      {/* Submit Button */}\n      <div className=\"flex items-center justify-between\">\n        <div className=\"text-sm text-gray-500\">\n          {formState.isDirty && (\n            <span>You have unsaved changes</span>\n          )}\n        </div>\n        \n        <button\n          type=\"submit\"\n          disabled={formState.isSubmitting || !formState.isValid}\n          className={`\n            px-6 py-2 rounded-md font-medium transition-colors\n            ${formState.isSubmitting || !formState.isValid\n              ? 'bg-gray-300 text-gray-500 cursor-not-allowed'\n              : 'bg-blue-600 text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2'\n            }\n            ${submitButtonClassName}\n            ${accessibilityMode ? 'text-lg px-8 py-3' : ''}\n          `}\n          aria-label={formState.isSubmitting ? 'Submitting form' : submitButtonText}\n        >\n          {formState.isSubmitting ? (\n            <div className=\"flex items-center\">\n              <Loader2 className=\"w-4 h-4 mr-2 animate-spin\" />\n              Submitting...\n            </div>\n          ) : (\n            submitButtonText\n          )}\n        </button>\n      </div>\n\n      {/* Form Status for Screen Readers */}\n      <div className=\"sr-only\" role=\"status\" aria-live=\"polite\">\n        Form is {formState.isValid ? 'valid' : 'invalid'}.\n        {formState.isSubmitting && 'Submitting form.'}\n      </div>\n    </form>\n  );\n};
