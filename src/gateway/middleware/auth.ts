import { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\nimport { rateLimit } from 'express-rate-limit';\n\n// JWT payload interface\ninterface JWTPayload {\n  userId: string;\n  email: string;\n  role: string;\n  permissions: string[];\n  iat: number;\n  exp: number;\n}\n\n// User interface\ninterface User {\n  id: string;\n  email: string;\n  role: string;\n  permissions: string[];\n  isActive: boolean;\n  lastLogin: Date;\n}\n\n// Authentication configuration\nconst authConfig = {\n  jwtSecret: process.env.JWT_SECRET || 'your-super-secret-jwt-key',\n  jwtExpiration: process.env.JWT_EXPIRATION || '24h',\n  refreshTokenExpiration: process.env.REFRESH_TOKEN_EXPIRATION || '7d',\n  bcryptRounds: 12,\n  maxLoginAttempts: 5,\n  lockoutTime: 15 * 60 * 1000, // 15 minutes\n};\n\n// In-memory store for refresh tokens (in production, use Redis or database)\nconst refreshTokens = new Map<string, { userId: string; expires: Date }>();\n\n// Rate limiting for auth endpoints\nconst authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 10, // 10 auth attempts per 15 minutes\n  message: 'Too many authentication attempts, please try again later.',\n  skipSuccessfulRequests: true,\n});\n\n// Login attempt tracking\nconst loginAttempts = new Map<string, { attempts: number; lockUntil?: Date }>();\n\n// Generate JWT tokens\nexport const generateTokens = (user: User) => {\n  const payload: JWTPayload = {\n    userId: user.id,\n    email: user.email,\n    role: user.role,\n    permissions: user.permissions,\n    iat: Math.floor(Date.now() / 1000),\n    exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60), // 24 hours\n  };\n\n  const accessToken = jwt.sign(payload, authConfig.jwtSecret, {\n    expiresIn: authConfig.jwtExpiration,\n    algorithm: 'HS256',\n  });\n\n  const refreshTokenPayload = {\n    userId: user.id,\n    type: 'refresh',\n    iat: Math.floor(Date.now() / 1000),\n    exp: Math.floor(Date.now() / 1000) + (7 * 24 * 60 * 60), // 7 days\n  };\n\n  const refreshToken = jwt.sign(refreshTokenPayload, authConfig.jwtSecret, {\n    expiresIn: authConfig.refreshTokenExpiration,\n    algorithm: 'HS256',\n  });\n\n  // Store refresh token\n  const refreshTokenId = Math.random().toString(36).substring(2, 15);\n  refreshTokens.set(refreshTokenId, {\n    userId: user.id,\n    expires: new Date(Date.now() + (7 * 24 * 60 * 60 * 1000)),\n  });\n\n  return {\n    accessToken,\n    refreshToken,\n    refreshTokenId,\n    expiresIn: 24 * 60 * 60, // 24 hours in seconds\n  };\n};\n\n// Verify JWT token\nexport const verifyToken = (token: string): JWTPayload | null => {\n  try {\n    const decoded = jwt.verify(token, authConfig.jwtSecret, {\n      algorithms: ['HS256'],\n    }) as JWTPayload;\n    \n    return decoded;\n  } catch (error) {\n    console.error('JWT verification error:', error);\n    return null;\n  }\n};\n\n// Check if user is locked out\nexport const isUserLocked = (email: string): boolean => {\n  const attempts = loginAttempts.get(email);\n  if (!attempts) return false;\n  \n  if (attempts.lockUntil && attempts.lockUntil > new Date()) {\n    return true;\n  }\n  \n  return false;\n};\n\n// Update login attempts\nexport const updateLoginAttempts = (email: string, success: boolean) => {\n  const attempts = loginAttempts.get(email) || { attempts: 0 };\n  \n  if (success) {\n    // Reset on successful login\n    loginAttempts.delete(email);\n  } else {\n    attempts.attempts++;\n    \n    // Lock user after max attempts\n    if (attempts.attempts >= authConfig.maxLoginAttempts) {\n      attempts.lockUntil = new Date(Date.now() + authConfig.lockoutTime);\n    }\n    \n    loginAttempts.set(email, attempts);\n  }\n};\n\n// Extract token from Authorization header\nexport const extractToken = (authHeader: string | undefined): string | null => {\n  if (!authHeader) return null;\n  \n  const parts = authHeader.split(' ');\n  if (parts.length !== 2 || parts[0] !== 'Bearer') return null;\n  \n  return parts[1];\n};\n\n// Authentication middleware\nexport const authMiddleware = (req: Request, res: Response, next: NextFunction) => {\n  // Skip auth for certain endpoints\n  const publicPaths = ['/api/docs', '/health', '/api/v1/auth/login', '/api/v1/auth/register', '/api/v1/auth/refresh'];\n  \n  if (publicPaths.some(path => req.path.startsWith(path))) {\n    return next();\n  }\n\n  // Extract token from Authorization header\n  const authHeader = req.headers.authorization;\n  const token = extractToken(authHeader);\n  \n  if (!token) {\n    return res.status(401).json({\n      error: 'No token provided',\n      message: 'Authorization header is required',\n      code: 'AUTH_MISSING',\n    });\n  }\n\n  // Verify token\n  const decoded = verifyToken(token);\n  if (!decoded) {\n    return res.status(401).json({\n      error: 'Invalid token',\n      message: 'JWT token is invalid or expired',\n      code: 'AUTH_INVALID',\n    });\n  }\n\n  // Add user info to request\n  req.user = {\n    id: decoded.userId,\n    email: decoded.email,\n    role: decoded.role,\n    permissions: decoded.permissions,\n  };\n\n  next();\n};\n\n// Role-based access control\nexport const requireRole = (roles: string | string[]) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'User must be authenticated',\n      });\n    }\n\n    const userRoles = Array.isArray(roles) ? roles : [roles];\n    const hasRole = userRoles.includes(req.user.role);\n    \n    if (!hasRole) {\n      return res.status(403).json({\n        error: 'Insufficient permissions',\n        message: `User role '${req.user.role}' is not authorized for this resource`,\n        requiredRoles: userRoles,\n        currentRole: req.user.role,\n      });\n    }\n\n    next();\n  };\n};\n\n// Permission-based access control\nexport const requirePermission = (permissions: string | string[]) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'User must be authenticated',\n      });\n    }\n\n    const userPermissions = req.user.permissions || [];\n    const requiredPermissions = Array.isArray(permissions) ? permissions : [permissions];\n    const hasPermission = requiredPermissions.every(permission => \n      userPermissions.includes(permission)\n    );\n    \n    if (!hasPermission) {\n      return res.status(403).json({\n        error: 'Insufficient permissions',\n        message: 'User does not have required permissions',\n        requiredPermissions,\n        userPermissions,\n      });\n    }\n\n    next();\n  };\n};\n\n// Optional authentication (doesn't fail if no token)\nexport const optionalAuth = (req: Request, res: Response, next: NextFunction) => {\n  const authHeader = req.headers.authorization;\n  const token = extractToken(authHeader);\n  \n  if (token) {\n    const decoded = verifyToken(token);\n    if (decoded) {\n      req.user = {\n        id: decoded.userId,\n        email: decoded.email,\n        role: decoded.role,\n        permissions: decoded.permissions,\n      };\n    }\n  }\n  \n  next();\n};\n\n// Refresh token middleware\nexport const refreshTokenMiddleware = (req: Request, res: Response, next: NextFunction) => {\n  const { refreshToken, refreshTokenId } = req.body;\n  \n  if (!refreshToken || !refreshTokenId) {\n    return res.status(400).json({\n      error: 'Invalid request',\n      message: 'Refresh token and token ID are required',\n    });\n  }\n  \n  // Verify refresh token\n  try {\n    const decoded = jwt.verify(refreshToken, authConfig.jwtSecret) as any;\n    \n    if (decoded.type !== 'refresh') {\n      return res.status(400).json({\n        error: 'Invalid token type',\n        message: 'Token must be a refresh token',\n      });\n    }\n    \n    const storedToken = refreshTokens.get(refreshTokenId);\n    if (!storedToken || storedToken.userId !== decoded.userId || storedToken.expires < new Date()) {\n      return res.status(400).json({\n        error: 'Invalid refresh token',\n        message: 'Refresh token is invalid or expired',\n      });\n    }\n    \n    // Generate new tokens\n    // In a real implementation, you'd fetch user from database\n    const mockUser: User = {\n      id: decoded.userId,\n      email: `user-${decoded.userId}@example.com`,\n      role: 'user',\n      permissions: ['read:own', 'write:own'],\n      isActive: true,\n      lastLogin: new Date(),\n    };\n    \n    const newTokens = generateTokens(mockUser);\n    \n    // Remove old refresh token\n    refreshTokens.delete(refreshTokenId);\n    \n    res.json({\n      accessToken: newTokens.accessToken,\n      refreshToken: newTokens.refreshToken,\n      refreshTokenId: newTokens.refreshTokenId,\n      expiresIn: newTokens.expiresIn,\n    });\n  } catch (error) {\n    return res.status(400).json({\n      error: 'Token refresh failed',\n      message: 'Invalid refresh token',\n    });\n  }\n};\n\n// Apply rate limiting to auth endpoints\nexport const authRateLimit = authLimiter;
